> 2024-12-18
> 

---

# Study

## 디자인 패턴

### 싱글톤 패턴

- 단 하나의 정적 인스턴스 객체 생성을 보장하는 패턴.
- 클래스 안에서 정적으로 인스턴스 객체를 가지고 있는 패턴이다.
- 객체를 만들떄는, 클래스 내에 객체를 가지고 있는지 확인한다.
    - 객체를 만드는 메서드 또한 `static` 으로 구현되어야 하는 이유는, 객체를 만들떄 **클래스 내에 객체를 가지고 있는지** 검사하기 떄문.
    - 이걸 정적 메서드로 구현하지 않으면, 인스턴스를 만들기 위해 인스턴스가 필요한 이상한 상황이 되어버린다. → 클래스 안에서 정적으로 인스턴스 객체를 가지고 있는것이기 때문.
- 스레드의 경쟁 상태 등등을 해결하려면, 후에 자바 스레드를 잘 배워서 한번 더구현해보자.

## CS 지식

### 운영체제

- 프로그램 실행시 각각의 역할
    - 드라이브 : 프로그램의 데이터를 영구적으로 저장한다.
    - 메인 메모리 : 프로그램이 실행되면, 운영체제에 의해 드라이브의 데이터를 메모리로 가져온다.
    - MMU : 데이터나 명령어들의 가상 주소를 물리 주소로 바꿔준다.
    - TLB : MMU가 이미 변환했던 메모리 주소를 다시 변환하지 않게 바로 물리 주소를 반환한다. (과정은 캐시메모리랑 비슷하게 동작)
    - 페이지테이블 : 운영체제가 프로그램 데이터/명령어의 가상 주소와 실제 주소 매핑 정보를 책처럼 만들어놓은것.
    - CPU : MMU를 통해 참고한 물리 주소를 통해서, 캐시 또는 메인 메모리에서 데이터나 명령어를 처리한다. (캐시에서 먼저 참조한다.)
    - 캐시 메모리 : CPU가 메모리에 있는 데이터나 명령어를 가져와 처리하기 전에, 먼저 캐시 메모리에 있는지 확인한다. 없으면 캐시 메모리에 블록 단위로 가져오고,(연속적으로 가져오게 된다) 처리한다.

### 네트워크

- 블로킹 I/O , 논블로킹 I/O
    - 블로킹 I/O로 설계된 서버와, 논블로킹 I/O로 설계된 서버는 어떻게 다른가? 에 대해 조금 알아보았다.
    - 논블로킹 I/O를 단일스레드로 처리해버리면, 멀티코어 환경에서는 꽤나 낭비인 상황이 생긴다.
        - 멀티코어는 여러 스레드를 컨텍스트 스위칭 없이 처리 가능하다.
        - 처리할수 있는 CPU가 4개인데, 1개의 스레드만 동작하면.. 아깝다.
    - 블로킹 I/O는 구현이 간단하다. 그냥 그 뿐이다. 사실상 논블로킹 I/O 가 압승이다.

---

# Problem Solving

## 백준

### [골드 5 : 항체인식](https://www.acmicpc.net/problem/22352)

- DFS 문제였는데, 문제 풀이를 좀더 깊게 생각하면 좋았을듯 하다.
    - 원상복구가 필요 없는 상황이었는데 원상복구를 생각해서 조금 꼬였다.
    - 백트래킹 아니다..

---

# Project

---

# Etc.

---
