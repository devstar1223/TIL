> 2024-12-23
> 

---

# Study

## 자바

### 이것이 자바다 9장(9.7~) , 11장, 12장(~12.3)

- 9장
    - 익명 객체에 대해 배웠다. 상속일경우 자식, 인터페이스일 경우 구현하는 클래스를 선언하지 않고, 오버라이딩해서, 객체를 만들어내는것.
    - 원래라면 상속/구현 클래스를 선언하고, 그 클래스를 인스턴스화 시키는게 맞지만, 단순하게 쓸 거면 빠르게 오버라이딩한 클래스를 선언해서 그걸 바로 인스턴스화 시켜주는것.
- 10장은 나에게 크게 의미있지 않아서 넘어갔다.
- 11장
    - 예외처리 방법에 대해 배웠다.
    - 문법오류 / 일반오류 / 실행오류
        - 문법오류 → 컴파일러가 입구컷함
        - 일반오류 → 컴파일러가 일반오류 터질거같으면 검사해보고, 예외처리 해줬으면 컴파일 해줌
        - 실행오류 → 컴파일러가 신경안씀. 터지면 본인 몫(프로그램 터짐)
    - 메서드에서 예외를 던지게 하는게 일반적이다.
        - 메서드가 예외를 던질수 있다면 `throws` 를 붙이고 던질수 있는 익셉션을 적어주거나, 너무 많다면 그냥 `Excption` , `throwable` 이런걸로 퉁 친다.
    - 커스텀 익셉션을 쓰는게 좋다.
        - 만들기 그렇게 안어렵다. 그냥 객체다.
- 12장
    - 자바의 라이브러리중 `java.base` 모듈에 대해 배웠다.
    - `Object` 클래스는 모든 참조 타입의 아버지.
    - `String`은 따로 선언되어도 `equals` 로 비교했을때 값만 같으면 `true` 반환한다. → `new String()` 이면 그런거 없다.
    - 객체의 동등성을 비교할땐 `equals()` 와 `hashCode()` 를 같이 오버라이딩 해서 사용한다.
        - 그러니까. 어떤 객체가 값만 같으면 `true` 시켜줘야 할때.

## 디자인 패턴

### 프로토 타입

- 객체 하나 만든다음에, 그 객체한테 복제 메서드를 만든다.
- 복제 메서드 만들면, 자기가 가지고 있는 값으로 그대로 객체를 하나 만든다음에, 그걸 반환해준다.
- 얕은 복사 → 복사된 객체가 원본 객체와 같은 참조를 공유함
- 깊은 복사 → 복사된 객체와 원본 객체가 독립적임
- 내부 참조가 많거나 복잡하면 깊은 복사를 구현하자. 꼬인다.

### 책임 연쇄 패턴

- 클래스 안에 필드에, 자신의 클래스와 같은 필드를 하나 넣어놓는다.
    - 그게 바로 내가 처리 못하면 다음에 처리해줄 객체
    - 당연히 생성자로 지정해놓으면, 생성이 안되니 따로 `set` 해줘야한다.
- 처리 메서드
    - 내가 처리할수 있다면? 처리한다.
    - 아니면? 지정해놓은 다음에 처리해줄 객체의 메서드를 실행시킨다.
    - 그 객체도 똑같이 처리메서드 돌아가면서 처리할수 있으면 처리한다.

---

# Problem Solving

## 백준

### [골드 4 : 미로 탈출](https://www.acmicpc.net/problem/14923)

- 어제 머리 꺠졌던건데, 해답보고 이해하려고 노력하니까 쉽게 이해했다.
- BFS를 더 더 깊게 알았다.
    - BFS는 무조건 최단경로를 반환한다 → 알았음
    - 도착 지점이 아닌, 어떤 지점에도 항상 최단으로 도착한다 → 몰랐음
    - 하지만, 벽을 부수던가 하는 식으로 최단 경로가 바뀔수 있다면, 중간 지점 또한 최단경로로 간다고 보장할 수 없고, 더 작게 갱신될 수 있으니, 벽을 부순 세계선과 벽을 부수지 않은 세계선을 분리해줘야함 → 핵심
- 꽤 어려운 생각과 사고.. 재미는 있네.

---

# Project

---

# Etc.

---
