> 2024-12-03
---
# Study

## 객체 지향

- 박우빈 클린코드 5-2 ~ 5-3

### Value Object

- 어떤 개념을 추상화하여 표현한 값 객체로, 3가지를 만족해야 한다.
    1. 불변성 → `final` 필드 / `setter` 금지
    2. 동등성 → 다른 인스턴스여도, 내부의 값이 같으면 같은 객체이다. (`equals()` & `hashCode` 재정의 필요)
    3. 유효성 검증 → 객체가 생성될 때 유효성을 보장해야 한다.
- 엔티티와의 차이
    - 엔티티는 식별자가 존재한다.
    - VO는 내부의 모든 값이 다 같아야 같은 객체다 (모든 필드가 식별자라고 봐도 무방)

### 일급 컬렉션

- 어렵게 설명하면. 다른 요소에게 사용 가능한 모든 연산을 지원하는 요소
- 쉽게 생각하면, 이런 느낌이다.
    - `CreditCard` 객체들을 리스트로 가지고 있는 `CreditCards` 객체
    - 이 일급 컬렉션은 단 하나의 컬렉션 필드만 가지고 있어야 한다.
- 객체들이 담긴 컬렉션으로 추상화해 의미를 담으며, 가공 로직을 넣을곳이 생긴다!
    - 외부에서 `CreditCard` 객체들에 대한 검사를 하나씩 돌리는것 보다, `CreditCards` 일급 컬렉션 내에서 가공 로직을 돌리는게 낫다.
- `getter` 같은거 쓸때는 외부 조작을 피하기 위해, 항상 새로운 컬렉션으로 만들어서 반환해줘야 한다.

## CS 지식

### 운영체제

- 선점형 스케줄링과 비선점 스케줄링의 차이에 대하여.
- 선점형 스케줄링은 현재 실행중인 프로세스를 강제로 중단하고 다른 프로세스한테 CPU를 할당한다.
    - 뭔가 나빠보이지만, 긴급한거 들어오면 멈춰놓고 처리한다는 뜻이다. → 컨텍스트 스위칭!
    - 실시간 시스템에선 이게 잘 쓰인다. → 현대에서는 실시간 시스템이 많이 쓰이고 중요하고..
- 비선점 스케줄링은 프로세스 종료/블록 되거나 CPU 할당 끝날때까지 무한 대기해야 한다.
- 우선순위 스케줄링의 구현 방식은 선점형 / 비선점형 두가지 종류가 있다.
    - 우선순위 스케줄링중 선점 스케줄링을 발생할때 기아 문제가 발생할 수 있다.
        - 기아문제 : 낮은 우선순위를 가진 프로세스가 높은 우선순위 프로세스가 계속 오면서 순번이 밀린다.
    - 이를 에이징 기법으로 해결할 수 있다.
        - 매 분마다 대기 중인 프로세스의 우선순위를 1씩 증가시킨다.

## 알고리즘

### 카데인 알고리즘

- DP 방식으로 최대 부분 누적합의 값을 구할때 쓴다.
- 특이하게 DP 테이블을 만들지 않고도 쓸 수 있다.
- `[1, 2, -3, 5, 10]` 의 누적합을 구해야 한다면..
    1. 구할 최대값을 `max` 라고 하자 (배열의 첫번째 값으로 초기화 한다.)
    2. 현재 누적합 최대값을 `current_sum` 이라고 하자. (배열의 첫번째 값으로 초기화 한다.
    3. 배열의 첫번쨰 값을 current_sum 으로 했으니, 두번째 (`i = 1` 부터 반복한다.)
    4. `current_sum` 을 둘중에 한 값으로 갱신한다.
        - 현재까지 누적 합`current_sum` + 현재 값 `array[i]`
        - 현재 값 `array[i]`
    5. 최대값 max 도 똑같이 최대로 갱신한다.
        - 현재 최대 값 `max`
        - `current_sum`
- 이 방식으로 $O(N)$ 의 시간 복잡도로 최대 부분 누적합의 값을 구할 수 있다.

---

## Problem Solving

## 백준

### [골드 4 : 점수따먹기](https://www.acmicpc.net/problem/1749)

- 카데인 알고리즘을 2차원에서 최대 합을 구하는 문제였다.
- 처음에 부분행렬 이라는걸 잘못 이해했는데, 사각형 범위로도 되는거였다. (단순히 한 행 또는 한 열 정도인줄 알았다.)
- 시간 복잡도가 무려 $O(N*M^3)$이 나왔는데, 어찌 통과됐다?
    - 이론상 2초제한에 $200^4$ 라서 안되지만. 어찌 된듯 하다.
    - $O(N*M^2)$ 으로도 풀 수 있다. 누적합을 매 행마다 구할 필요가 없기 떄문.
        - 물론 그렇게 풀어야 한다면. 골드 4 따위가 아닐것이다..
- DP 방식의 카데인 알고리즘과. 브루트 포스가 혼합된 문제였다,
- 답을 좀 참고해서 풀었다. 어렵다 어려워..

---

## Project

---

## Etc.

---
