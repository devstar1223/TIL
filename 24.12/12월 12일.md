> 2024-12-12
> 

---

# Study

## 디자인패턴

### 파사드 - 생성패턴

- 서브시스템들을 모조리 처리해주는 메인시스템이 있고, 사용자는 그 메인시스템만 쓰면 된다!
- 딸깍 한번에 이거 저거 다 실행되는 스타일.

### 전략패턴 - 행위패턴

- 객체가 하는 행위를 `interface` 로 명시만 해놓고, 다양한 구현체들을 동적으로 바꿔가며 선택하며 사용한다.
- 상황에 따라 필요한 전략을 내가 선택해가며 쓸 수 있다.
- 이 전략 저 전략 변경하고, 새로운 클래스가 추가되도 `inteface` 기반으로 구현하니 문제 없다. (무슨 총알이든 간에. 총알이기만 하면 다 총에 들어간다)

### 템플릿 메서드 - 행위패턴

- 공통되는 작업은 추상클래스에서 구현까지 하고, 객체마다 다른 세부 작업은 일단 구현하라고 명시만 해놓는다.
- 그리고 공통 작업 + 세부 작업 한방에 묶어서 템플릿으로 만들어서 처리한다.
- 세부 작업은 구현체들이 세부 작업 명시해주면 끝!

## CS 지식

### 운영체제

- 프로그램을 실행하면, 운영체제가 이를 프로세스로 만들고, 해당 프로세스에 CPU를 할당하여 처리한다.
- 프로세스는 메모리 위에 올라가게 되는데, 메모리를 어떻게 할당할것인가? 가 바로 페이징 또는 세그먼테이션
- 페이징
    - 페이지 라는 고정적인 단위로 메모리를 나누고 프로세스에 할당한다.
    - 페이지 크기 1MB 인데 프로세스 차지 메모리 1KB 면 1023KB 만큼 내부 공간 손해 → **내부단편화**
- 세그먼테이션
    - 프로세스가 메모리를 할당 받아야 할떄. 프로세스가 차지하는 메모리 만큼 메모리 할당 (딱코)
    - 1MB 짜리 프로세스 할당 끝났는데, 계속 2MB 이상 프로세스만 들어오면 1MB 공간은 계속 놀면서 잉여 공간이 되버림 → 외부 단편화

---

# Problem Solving

## 백준

### [실버 1 : 접두사](https://www.acmicpc.net/problem/1141)

- 문자열을 잘 정렬해서 그리디 방식으로 풀면 된다.
- `substring` 의 시간 복잡도는 최대 $O(L)$ 이고. $L$은 문자열의 평균 길이! (최장 길이라고 생각하자)

---

# Project

---

# Etc.

---
